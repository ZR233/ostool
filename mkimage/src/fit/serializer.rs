//! FIT序列化器
//!
//! 将FIT数据结构序列化为设备树格式，生成符合U-Boot FIT规范的二进制数据

use crate::fit::types::FitImage;
use crate::compression::traits::CompressionInterface;
use crate::error::Result;

/// FIT序列化器
/// 负责将FitImage结构转换为设备树格式的二进制数据
pub struct FitSerializer {
    magic: [u8; 4],
    version: u32,
}

impl FitSerializer {
    /// 创建新的FIT序列化器
    pub fn new() -> Self {
        Self {
            // FIT magic number: 0xd00dfeed (little endian)
            magic: [0xed, 0xfe, 0x0d, 0xd0],
            version: 0x10, // FIT version 1.0
        }
    }

    /// 序列化FIT image为二进制数据
    pub fn serialize(&self, fit_image: &FitImage, _compressor: &dyn CompressionInterface) -> Result<Vec<u8>> {
        // 简化实现：创建基本的FIT二进制结构
        let mut result = Vec::new();

        // 1. 添加FIT头部
        result.extend_from_slice(&self.magic);

        // 2. 添加版本信息
        result.extend_from_slice(&self.version.to_le_bytes());

        // 3. 创建简化的设备树数据结构
        let fdt_data = self.create_simple_fdt_data(fit_image)?;

        // 4. 添加设备树数据
        result.extend_from_slice(&fdt_data);

        // 5. 计算并添加CRC32校验和
        let crc_value = crate::crc::calculate_crc32(&result);
        result.extend_from_slice(&crc_value.to_le_bytes());

        Ok(result)
    }

    /// 创建简化的设备树数据
    fn create_simple_fdt_data(&self, _fit_image: &FitImage) -> Result<Vec<u8>> {
        let mut fdt_data = Vec::new();

        // 简化的FDT头部信息
        // Magic: 0xd00dfeed
        fdt_data.extend_from_slice(&[0xed, 0xfe, 0x0d, 0xd0]);

        // Total size (稍后填充）
        let size_pos = fdt_data.len();
        fdt_data.extend_from_slice(&[0; 4]);

        // Offsets table (稍后填充）
        let offsets_pos = fdt_data.len();
        fdt_data.extend_from_slice(&[0; 4]);

        // Version: 17 (DTB版本）
        fdt_data.extend_from_slice(&[17, 0, 0, 0]);

        // Last compatible version (可选）
        fdt_data.extend_from_slice(&[16, 0, 0, 0]);

        // Boot CPU ID (可选）
        fdt_data.extend_from_slice(&[0; 4]);

        // Properties string length (稍后计算）
        let _strings_pos = fdt_data.len();
        fdt_data.extend_from_slice(&[0; 4]);

        // Properties structure length (稍后计算）
        let struct_pos = fdt_data.len();
        fdt_data.extend_from_slice(&[0; 4]);

        // 添加一个简单的根节点和属性
        let root_node_start = fdt_data.len();

        // Node name (空字符串表示根节点)
        fdt_data.push(0);

        // Node properties (简化示例）
        let properties = vec![
            ("model", "Test FIT Image".as_bytes()),
            ("compatible", "test-vendor,test-device".as_bytes()),
            ("description", "Generated by mkimage-rs".as_bytes()),
        ];

        let mut current_offset = root_node_start + 1; // +1 for null terminator
        for (name, value) in properties {
            // Property name
            fdt_data.extend_from_slice(name.as_bytes());
            fdt_data.push(0);
            current_offset += name.len() + 1;

            // Property value length and data
            let value_len = value.len();
            fdt_data.extend_from_slice(&(value_len as u32).to_le_bytes());
            fdt_data.extend_from_slice(value);
            current_offset += 4 + value_len;
        }

        // Node结束标记
        fdt_data.push(0);
        fdt_data.push(0);

        // 更新sizes
        let total_size = fdt_data.len() as u32;
        fdt_data[size_pos..size_pos+4].copy_from_slice(&total_size.to_le_bytes());

        let strings_size = 0u32; // 简化：没有单独的strings section
        fdt_data[offsets_pos..offsets_pos+4].copy_from_slice(&strings_size.to_le_bytes());

        let struct_size = (fdt_data.len() - struct_pos) as u32;
        fdt_data[struct_pos..struct_pos+4].copy_from_slice(&struct_size.to_le_bytes());

        Ok(fdt_data)
    }
}

impl Default for FitSerializer {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compression::gzip::GzipCompressor;
    use crate::fit::types::{FitImage, FitComponent, FitComponentType, FitConfiguration};

    #[test]
    fn test_fit_serializer_creation() {
        let serializer = FitSerializer::new();
        assert_eq!(serializer.magic, [0xed, 0xfe, 0x0d, 0xd0]);
        assert_eq!(serializer.version, 0x10);
    }

    #[test]
    fn test_create_simple_fit_image() {
        let mut fit_image = FitImage::new();
        fit_image.description = "Test FIT".to_string();

        // 添加kernel组件
        let kernel_data = vec![1, 2, 3, 4];
        let kernel_component = FitComponent::new(FitComponentType::Kernel, kernel_data)
            .with_description("Test kernel")
            .with_load_address(0x80080000)
            .with_entry_point(0x80080000);
        fit_image.add_image("kernel".to_string(), kernel_component);

        // 添加配置
        let config = FitConfiguration::new()
            .with_description("Test config")
            .with_kernel("kernel")
            .with_compatible("test-vendor,test-device");
        fit_image.add_configuration("default".to_string(), config);
        fit_image.default = Some("default".to_string());

        // 序列化
        let serializer = FitSerializer::new();
        let compressor = GzipCompressor::new_disabled();
        let result = serializer.serialize(&fit_image, &*compressor);

        assert!(result.is_ok(), "Serialization should succeed");

        let serialized_data = result.unwrap();
        // 验证magic number
        assert_eq!(&serialized_data[0..4], [0xed, 0xfe, 0x0d, 0xd0]);

        // 验证CRC32存在
        assert!(serialized_data.len() >= 8, "Should have header + CRC32");
    }

    #[test]
    fn test_empty_fit_image() {
        let fit_image = FitImage::new();
        let serializer = FitSerializer::new();
        let compressor = GzipCompressor::new_disabled();

        let result = serializer.serialize(&fit_image, &*compressor);
        assert!(result.is_ok());
    }
}